#+TITLE: Djole's Emacs Config
#+AUTHOR: Djordje Knezevic
#+EMAIL: djolereject@gmail.com
#+PROPERTY: header-args :results silent :tangle (expand-file-name "settings.el" config-dir)

* About
Last Emacs bankruptcy forced me to try a different route - put everything in org file and have it documented, explained and never stale.

Explanations combined with code in one file is effectuating old paradigm of [[https://github.com/limist/literate-programming-examples][Literate Programming]], which might have it's flaws but lisp configuration file is exactly where it shines. I will try not to underestimate "Literate" part of this concept and give thorough explanations for every line of code along with guiding principles for bigger sections.

This is obviously opinionated setup, being my actual working ~init~, but I made some effort making parts of it separate and possible to apply or exclude on it's own. Reminding future me on what the hell I was thinking when I included something is part of the reason I'm writing this, but I also hope it can be of help to someone trying to learn how Emacs initialization works. I had tremendous help from other people's init directories and I hope detailed instructions presented here could help someone in similar fashion.

For somebody who is starting his journey with Emacs, this repository can serve as a starting point for personal setup. Just copying it will leave you with nice looking and reasonable settings. I have a tendency for minimalism so this should be easy to build upon. Similarly, separation of code blocks makes it trivial to remove parts that are of no interest in someone else's workflow.

If you find something achievable in simpler or more efficient way, please feel free to tell me. This is in no way finished and I don't expect it ever to be.

** Files in .emacs.d
*** settings.org
This is where the magic happens... [[https://org-babel.readthedocs.io/en/latest/][Babel]] extracts code from this file copying it to self-created ~config/settings.el~ which Emacs uses for initialization. Using that extracted code ~Custom~ creates ~config/custom.el~ and lists packages mentioned, preparing them for download and installation.

- Source of all packages is [[https://stable.melpa.org/][MELPA Stable]], which might not be enough for somebody who wants newest and shiniest toys. You can replace package source with [[https://melpa.org/packages][MELPA]] or [[http://marmalade-repo.org/packages/][Marmelade]], just be aware that they both have their problems and never rely 100% on having the source available at all times. Emacs package sources are still evolving ecosystem and everything relies on your specific needs, but ~melpa-stable~ should suffice to most. 
- Strategy used for installation is [[https://github.com/jwiegley/use-package][use-package]], which to me looks superior to all other techniques (and I tried them all). Possibility to require and define package in the same place where you are setting its behavior does wonders for readability. Some packages might make you jump through hoops if you try to install them this way, but it's worth it.
*** init.el
In ~init~ we have to set some things beforehand so ~settings~ can run consistently between reboots and there is no clutter created in Emacs root directory.
- ~(package-initialize)~ is there just because ~Custom~ would put it there anyway being the starting file of initialization.
- ~config-dir~ and ~data-dir~ are names of directories that we want for variables in ~no-littering~ package. When I started using ~no-littering~ it became obvious that some other transient files should have their place in those directories too so I put their creation in pre-processing stage.
*** README
Just a link to ~settings.org~ so everything looks nice on github.
* Prerequisites
Minimum Emacs version for this settings to work is ~26~, because it comes with org version ~9.1~. It's too much hustle to reinstall org from this file, because it's already loaded when it's evaluated.
Before we go on with installing packages it's essential to configure some things. Everything in this section concerns initializing ~set-package~ and making sure we don't create clutter in install directory.
** Sources
Having only one source repository keeps things simple and I don't need fancy, rare or bleeding edge packages. If that need arises I can always download it locally and set local source for ~use-package~, making it even more secure.

#+BEGIN_SRC emacs-lisp
(require 'package)
(add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
(package-initialize)
#+END_SRC
** TLS Setup
Before installing anything, it's essential to setup TLS certificate because Emacs is not handling that in ideal way. For openssl to work on OSX we need to install ~libressl~, which is easiest to do via [[https://brew.sh/][Homebrew]]: ~brew install libressl~. Other systems may need some other setup or even none (which I believe goes for any popular Linux distro).

#+BEGIN_SRC emacs-lisp
(require 'gnutls)
(add-to-list 'gnutls-trustfiles "/usr/local/etc/openssl/cert.pem")
#+END_SRC
** use-package
I already explained why I like ~use-package~, so I won't go further with reasons it's my preferred installer. This setup could obviously work with some other macro, but I'm not sure if some discrepancies could arise.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
(eval-when-compile
  (require 'use-package))
#+END_SRC
** no-littering
[[https://github.com/emacscollective/no-littering][no-littering]] package is the first we are going to install. It's job is to make sub-directories in ~.init.d~ and save all temporary files there. This reduces clutter and helps with having one place to look in case of something missing.
- ~/config~ is for auto generated files that would end up cluttering ~init.el~. Process of installation creates ~settings.el~ and ~custom.el~ files, but any package that needs configuration files should use this directory to save them.
- ~/data~ serves as temporary directory for all packages. This is place for ~auto-save~ and ~backup~, along with any other package that needs to save some transient data.

#+BEGIN_SRC emacs-lisp
  (use-package no-littering
    :ensure t
    :init (progn
            (setq no-littering-etc-directory config-dir)
            (setq no-littering-var-directory data-dir)
            :config (progn
                      (require 'no-littering)
                      (require 'recentf)
                      (add-to-list 'recentf-exclude no-littering-var-directory)
                      (add-to-list 'recentf-exclude no-littering-etc-directory)
                      (setq backup-directory-alist
                            `((".*" . ,(no-littering-expand-var-file-name "backup/"))))
                      (setq auto-save-file-name-transforms
                            `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
                      (setq custom-file (expand-file-name "custom.el" config-dir))
                      (when (file-exists-p custom-file)
                        (load custom-file)))))
#+END_SRC
** Suppress warnings
Some packages are sending unnecessary warnings while installed through ~use-package~ and it's bothering me, so this is just for my OCD. Default value for this variable is ~:warning~ and I boosted it up to ~:error~.

#+BEGIN_SRC emacs-lisp
(setq warning-minimum-level :error)
#+END_SRC
* General Settings
In this section we are dealing with overall look and behavior of Emacs. Values and packages set here are the ones that will influence every mode in Emacs and it would be good for you to understand what they are doing. I tried to add links to repos or other pages of importance that can shine some light on what given package is trying to achieve.
** Set defaults
*** Maximize Emacs
GUI app should take as much screen real estate as possible.

#+BEGIN_SRC emacs-lisp
(custom-set-variables
 '(initial-frame-alist (quote ((fullscreen . maximized)))))
#+END_SRC
*** Cursor appearance
I want text cursor looking like ~bar~ (other options include: ~box~, ~hollow~, ~hbar~, ~nil~). This is purely personal preference, play with it and find what works for you.

#+BEGIN_SRC emacs-lisp
(setq-default cursor-type 'bar)
#+END_SRC
*** Default mode
Opening files with unknown extension is best to start in ~text-mode~ and specify later.

#+BEGIN_SRC emacs-lisp
(setq initial-major-mode 'text-mode)
#+END_SRC
** Remove unwanted
*** Decorations
If you use your Emacs without mouse, toolbar and scrollbar are just wastes of screen space. If you are not there yet, you will be in time.

#+BEGIN_SRC emacs-lisp
(tool-bar-mode 0)
(scroll-bar-mode 0)
#+END_SRC
*** Messages
While these screens might be helpful for beginners when they start their journey with Emacs, after a while they become annoyances.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
(setq inhibit-splash-screen t)
(setq initial-scratch-message nil)
#+END_SRC
*** Confirmation
Expect y/n instead of yes/no when needing confirmation - this really ought to be default.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Tooltips
I never need GUI tooltips in Emacs and can't imagine type of usage that welcomes it.

#+BEGIN_SRC emacs-lisp
(setq tooltip-use-echo-area t)
#+END_SRC
*** Sound Beep
Beep is frequent, irritating and not at all helpful. Send it to message screen instead of speakers so you still have some kind of visible cue that it happened.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function (lambda () (message "*beep*")))
#+END_SRC
** Buffer specific
*** Switching
It's possible to just use ~other-window~ command and add some keybindings to it, but [[https://github.com/abo-abo/ace-window][ace-window]] is easier to use and brings some additional options.

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t
  :config (progn
            (global-set-key (kbd "M-o") 'ace-window)
            (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))))
#+END_SRC
*** Clear
It might be personal quirk but most frequent use of ~C-l~ command for me is to move cursor position to top of the screen, so I usually type ~C-l C-l~. Whenever something is repeating, aim for simplification.

#+BEGIN_SRC emacs-lisp
(setq recenter-positions '(top middle bottom))
#+END_SRC
*** Cursor position
Show current row and column at the bottom of the buffer. This is helpful in most modes and unobtrusive in rest of them.

#+BEGIN_SRC emacs-lisp
(setq column-number-mode t)
#+END_SRC
*** Wrap lines
Only case known to me where you would want unwrapped text is parsing binary files. It's better to override behavior for those purposes, then to scroll left-right through buffer in all other scenarios.

#+BEGIN_SRC emacs-lisp
(global-visual-line-mode 1)
#+END_SRC
*** Double space sentences
American typist's convention for end of the sentence can cause trouble in some modes. If you need it just turn on ~M-x repunctuate-sentences~.

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
** Editing
*** Fast buffer kill
Confirming or picking exact buffer when trying to kill it wastes time, just leave finger on Control and do it faster with ~C-x C-k~.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-k") 'kill-this-buffer)
#+END_SRC
*** Pasting text
When typing over selected text, I want it replaced and not appended. One of the rare cases when Emacs is in the wrong compared to majority of editors.

#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC
*** Undo Tree
Interesting and efficient way of dealing with undo in Emacs. Takes some time to get used to, but ability to move through undo/redo tree can be great.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :init (global-undo-tree-mode))
#+END_SRC
*** Whitespaces
Really simple package, but I find it incredibly useful. Replaces rows of whitespaces with just one or deletes single whitespace. Shortcut is ~M-Space~.

#+BEGIN_SRC emacs-lisp
(use-package shrink-whitespace
  :ensure t
  :config (global-set-key (kbd "M-SPC") 'shrink-whitespace))
#+END_SRC
** OS-specific
For now, I only customized things related to OSX because that's the system I'm spending most of my time in. I plan to do fine tuning for few popular distros, mainly Ubuntu.

*** OSX
- Bound ~Control~ to ~Caps-Lock~ key system-wide, not inside Emacs. This is something I encourage everybody to try.
- ~Option~ is ~Meta~ by default, no need to do anything there.
- Left ~Cmd~ is ~Super~ by default, no need to do anything there.
- Right ~Cmd~ is ~Control~, it's the only key that makes sense for right hand.
- Suppress killing and minimizing Emacs with OS shortcuts.

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (global-set-key (kbd "s-q") nil)
  (global-set-key (kbd "s-w") nil)
  (global-set-key (kbd "C-~") nil)
  (setq mac-right-command-modifier 'control))
#+END_SRC
** Minibuffer
There are lot of packages that are trying to influence all aspects of working with Emacs and consequentially change behavior of minibuffer. I tried working with ~Helm~, but in the end decided I don't need such an invasive package because I started spending time catching it's quirks around some other big packages. 

Another possible route is having just ~ido-mode~ and big number of specialized settings for different scenarios which also tends to become clutter after a while. 

For now, I settled with ~ivy~ which is a little bit more "overall solution" than I'm comfortable with, but it keeps things confined. I might rethink this decision if it gets too much in the way.
**** Ivy
[[https://github.com/abo-abo/swiper/blob/master/doc/ivy.org][ivy]] is improved version of ~ido-mode~ with much more customization options. It removes need for ~ubiquitous~ and ~smex~ and have good overall feel. I just started using it recently but I like what I'm seeing.

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t)
(use-package swiper
  :ensure t
  :diminish ivy-mode
  :bind (("C-s" . swiper)
         ("C-r" . swiper)
         ("C-c C-r" . ivy-resume)
         ("C-c h m" . woman)
         ("C-x b" . ivy-switch-buffer)
         ("C-c u" . swiper-all))
  :config
  (ivy-mode 1)
  (setq ivy-use-virtual-buffers t))
(use-package counsel
  :ensure t
  :bind (("M-x" . counsel-M-x)
         ("C-x C-f" . counsel-find-file)
         ("C-h f" . counsel-describe-function)
         ("C-h v" . counsel-describe-variable)
         ("C-h i" . counsel-info-lookup-symbol)
         ("C-h u" . counsel-unicode-char)
         ("C-c k" . counsel-rg)
         ("C-x l" . counsel-locate)
         ("C-c g" . counsel-git-grep)
         ("C-c h i" . counsel-imenu)
         ("C-x p" . counsel-list-processes))
  :config
  (ivy-set-actions
           'counsel-find-file
           '(("j" find-file-other-window "other")))
  (ivy-set-actions 'counsel-git-grep
                   '(("j" find-file-other-window "other"))))
#+END_SRC
**** Which key
[[https://github.com/justbur/emacs-which-key][which-key]] opens popup after entering incomplete command. Delay of one second gives enough time to finish command without seeing it, and if I'm stuck it shows available endings to entered prefix.

#+BEGIN_SRC emacs-lisp
(use-package which-key 
  :ensure t
  :config
  (which-key-setup-side-window-right-bottom)
  (which-key-mode))
#+END_SRC
*** Reverting buffers
When file edited in buffer changes from some outside source (say, ~git reset~), I expect buffer to render that change immediately.

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+END_SRC
*** Writing and spelling
English is not my native language so I need more help than some. I still try to keep spellcheck unobtrusive and grammar or style suggestions on minimum so this setting could just be starting point for someone who needs more substantial suggestions or is writing more in natural than programming languages.

**** fly-spell
[[https://github.com/d12frosted/flyspell-correct][flyspell-correct]] is wrapper for ~fly-spell~ with interface that can easily work with ~ivy~, ~helm~ or simple popup presentation. 

- ~fly-spell~ uses separate program to compare words. ~brew install aspell~ is easy way to do it on Mac but you have to bind it's path manually.
- Correcting previous word while typing is the most common use-case so it's bound to convenient shortcut: ~C-;~

#+BEGIN_SRC emacs-lisp
(use-package flyspell-correct-ivy
  :ensure t
  :config (progn
            (when (eq system-type 'darwin)
              (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))
              (setq exec-path (append exec-path '("/usr/local/bin"))))
            (add-hook 'text-mode-hook 'flyspell-mode)
            (define-key flyspell-mode-map (kbd "C-;") 'flyspell-correct-previous-word-generic)))
#+END_SRC
**** writegood-mode
[[https://github.com/bnbeckwith/writegood-mode][writegood-mode]] is checking for weasel words, passive voice or duplicates in prose.

#+BEGIN_SRC emacs-lisp
(use-package writegood-mode
  :ensure t)
#+END_SRC
** Meta
Emacs configuration is job that is never really finished so I have some convenient shortcuts concerning ~settings.org~ file.
*** Open
Speed dial ~settings.org~ with ~C-c i~.

#+BEGIN_SRC emacs-lisp
 (defun djole/find-settings ()
    "Edit settings.org"
    (interactive)
    (find-file (concat user-emacs-directory "settings.org")))
  (global-set-key (kbd "C-c i") 'djole/find-settings)
#+END_SRC
*** Reload
When we change settings.org, we want it quickly reloaded to observe how changes influenced running Emacs. Shortcut is ~C-c r~.

#+BEGIN_SRC emacs-lisp
(defun djole/reload-settings ()
  "Reloads settings.org at runtime"
  (interactive)
  (org-babel-load-file (expand-file-name "settings.org" user-emacs-directory)))
(global-set-key (kbd "C-c r") 'djole/reload-settings)
#+END_SRC
* Theme
Picking theme is personal for everybody so if you don't like my choice, explore some resources out there and pick one that suits you. There are lot of repositories out there so you shouldn't limit yourself to ~base16~, [[https://belak.github.io/base16-emacs/][but they do have some variety.]]

#+BEGIN_SRC emacs-lisp
  (use-package base16-theme
    :ensure t
    :if window-system
    :config (load-theme 'base16-apathy t))
  ;; light candidates: 'base16-mexico-light 'base16-atelier-cave-light
  ;; dark candidates: 'base16-oceanicnext 'base16-materia 'base16-apathy 'base16-atelier-savanna 'base16-chalk 'base16-google-dark 'base16-gruvbox-dark-pale 
#+END_SRC
* Org Mode
Customizing one of the biggest and most popular packages for Emacs could be infinite job on itself, but I try to go with defaults as much as I can. 

!!! TODO: enhance this section with templates and captures.

** General Layout
*** Indentation
Indent everything to the level of it's title, but skip further indentation of code.

#+BEGIN_SRC emacs-lisp
(setq org-startup-indented t)
(setq org-edit-src-content-indentation 0)
#+END_SRC
*** Code highlights
Add some colors to code using native mode for given language.

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC
*** Code confirmation
I never accidentally type ~C-c C-c~ so there is no need for confirmation.

#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC
*** Tabs in code
Tabs should behave in expected way when in code block, default is quite confusing.

#+BEGIN_SRC emacs-lisp
(setq org-src-tab-acts-natively t)
#+END_SRC
*** Emphasized text
Display emphasis immediately: *Bold*, /italic/...

#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC
*** Special symbols
Present symbols as intended (pi -> \pi{}).

#+BEGIN_SRC emacs-lisp
(setq org-pretty-entities t)
#+END_SRC
*** Bullets
 [[https://github.com/sabof/org-bullets][org-bullets]] are presenting nice looking bullets instead of asterisks.
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :config
  (add-hook 'org-mode-hook 'org-bullets-mode))
#+END_SRC
** Bindings
While trying to be as close to defaults as possible, I still have some preferences when it comes to binding keys in ~org-mode~.
*** Changing levels
- Promoting/Demoting with Super-left/right
- Moving subtree with Super-up/down
- This leaves M-right/left to behave same as in other modes

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook          
          '(lambda ()
             (define-key org-mode-map (kbd "M-<right>") 'forward-word)
             (define-key org-mode-map (kbd "M-<left>") 'backward-word)
             (define-key org-mode-map (kbd "s-<up>") 'org-move-subtree-up)
             (define-key org-mode-map (kbd "s-<down>") 'org-move-subtree-down)
             (define-key org-mode-map (kbd "s-<right>") 'org-do-demote)
             (define-key org-mode-map (kbd "s-<left>") 'org-do-promote)))
#+END_SRC
*** Template for elisp code
Standard insert is done via ~<s + TAB~, and I mostly need emacs-lisp, so I made ~<el~ template.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-structure-template-alist
	       '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC
** Appearance
Just one way for ~org-mode~ to look nice. I copied most of it from somewhere and added couple of things, but it's matter of personal preference so feel free to play with it. One more important note is that layout settings are tightly related to theme you are using, so this section is something you will probably often fine tune.

#+BEGIN_SRC emacs-lisp :tangle no
(let*
      ((variable-tuple (cond
                        ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
                        ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
                        ((x-list-fonts "Verdana")         '(:font "Verdana"))
                        ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
                        (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
       (base-font-color     (face-foreground 'default nil 'default))
       (headline           `(:inherit default :weight normal :foreground ,base-font-color)))

    (custom-theme-set-faces 'user
                            `(org-level-8 ((t (,@headline ,@variable-tuple))))
                            `(org-level-7 ((t (,@headline ,@variable-tuple))))
                            `(org-level-6 ((t (,@headline ,@variable-tuple))))
                            `(org-level-5 ((t (,@headline ,@variable-tuple))))
                            `(org-level-4 ((t (,@headline ,@variable-tuple))))
                            `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.33))))
                            `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.33))))
                            `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.33))))
                            `(org-document-title ((t (,@headline ,@variable-tuple :height 1.33 :underline nil))))))
#+END_SRC
** Exporters
I tried with ~pandoc-mode~ but it looks too intrusive, and ~ox-pandoc~ has some problems installing from ~melpa-stable~. Exporting to markdown is only thing I need for now so I will return to this section when exporting to PDF or latex calls for more.

TODO: Needs more exporting options!

#+BEGIN_SRC emacs-lisp
(use-package ox-gfm
  :after (org)
  :ensure t)
#+END_SRC
** Agenda
*** Global Shortcuts
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c l") 'org-store-link)
(global-set-key (kbd "C-c a") 'org-agenda)
(global-set-key (kbd "C-c c") 'org-capture)
(setq org-log-done t)
#+END_SRC
*** Files
Define default place for my agenda
#+BEGIN_SRC emacs-lisp
(setq org-agenda-files (list "~/org/test.org"))
#+END_SRC
** Templates
*** Temp
#+BEGIN_SRC emacs-lisp
;; (setq org-default-notes-file "~/org/vezba.org")
;; (setq org-capture-templates '())
;; (add-to-list 'org-capture-templates '("a" "VEZBA" entry (file+olp+datetree org-default-notes-file) "* \
;; %(djole/org-capture-read-multiple \"****\" \"vezba\" :dynamic \"[,:]\")
;; "))

;;  sets: %^{sets}\t reps: %^{reps}\t weight: %^{weight} kg
;;    Participants: %(my/org-capture-read-multiple \"Participants\" :dynamic \"[,:]\")
;; Sets: %^{Sets}  Reps: %^{Reps} Weight: %^{Weight}
;; %^{prompt|Exercise|Superset}
;; (setq org-default-notes-file "~/org/journal.org")
;; (setq org-capture-templates '())

;; (defun djole/org-heading-catalogue (buffer level)
;;   "Send org buffer and level from which you want list of headings. Returns list of strings."
;;   (mapcar (lambda (x) (elt x 4)) 
;; 	  (seq-filter (lambda (x) (= (nth 0 x) level)) (org-map-entries '(org-heading-components)))))
;; (defun djole/org-ac-headings (buffer level)
;;   (completing-read "Izaberi: " 
;; 		   (djole/org-heading-catalogue buffer level)))

;; (defun stari (field completion &optional delims)
;;  (let* ((buffer (if (equal (buffer-name) "*Capture*")
;;                      (org-capture-get :buffer)
;;                    (current-buffer)))
;;          (completion (if (eq completion :dynamic)
;;                          '("1" "2")
;;                        completion)))
;;     (with-current-buffer buffer
;;       (let ((org-last-tags-completion-table completion)
;;             org-completion-use-ido)
;;         (org-completing-read-no-i (format "%s: " field)
;;                                   #'org-tags-completion-function)))))

;; (add-to-list 'org-capture-templates '("a" "Proba" entry (file+olp+datetree org-default-notes-file) "* \
;; Naslov: %(stari \"Participants\" :dynamic \"[,:]\")
;; Neki tekst"))
#+END_SRC
*** Autocomplete functions
Helper functions to autocomplete headings in capture files.
#+BEGIN_SRC emacs-lisp
(defun org-heading-list (buffer level)
  "Send org buffer and level from which you want list of headings. Returns list of strings."
  (with-current-buffer buffer
    (mapcar (lambda (x) (elt x 4)) 
	    (seq-filter (lambda (x) (= (nth 0 x) level)) (org-map-entries '(org-heading-components))))))
(defun active-capture-buffer ()
  (if (equal (buffer-name) "*Capture*")
      (org-capture-get :buffer)
    (current-buffer)))
(defun org-autocomplete (prefix level)
  (org-completing-read-no-i (concat prefix ": ") (org-heading-list (active-capture-buffer) level)))
#+END_SRC
*** Training related captures
#+BEGIN_SRC emacs-lisp
(setq org-training-file "~/org/training.org")
(setq org-capture-templates '())

(add-to-list 'org-capture-templates '("g" "Gym Session" entry (file+olp+datetree org-training-file) "* %(org-autocomplete \"theme\" 4)" :time-prompt t :tree-type week))
(defun goto-last-heading ()
  (interactive)
  (org-end-of-subtree))

(defun org-kraj ()
  (interactive)
  (let ((org-special-ctrl-a/e t))
    (if (condition-case nil
            (outline-forward-same-level 1)
          (error t))
        (progn
          (goto-char (point-max))
          (outline-back-to-heading))
      (outline-previous-visible-heading 1))
    (org-end-of-line 1)))
(add-to-list 'org-capture-templates '("e" "Exercise" entry (file+function org-training-file org-kraj) "* kurcic"))
#+END_SRC
* Git
Version control is important part of Emacs ever since [[https://github.com/magit/magit][Magit]] entered the scene showing factual difference between "porcelain" and "plumbing". After spending some time getting used to it, ~Magit~'s efficiency will look like magic to seasoned git user.

** Magit
Learn it, use it and never look back on days of typing something like: 

~git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit~

I'm not a fan of frequent confirmations for common tasks, so staging all files is added to 'no confirm' list.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind ("C-x g" . magit-status)
  :config (add-to-list 'magit-no-confirm 'stage-all-changes))
#+END_SRC
** Git Gutter
[[https://github.com/syohex/emacs-git-gutter][git-gutter]] is displaying diff from last stage in left column (presenting changed lines as: "~", added: "+" and removed: "-"). One of the selling points for this package is that every chunk can be separately staged.

I find ~M-g~ to be good prefix for ~git-gutter~ commands but use whatever works for you.

#+BEGIN_SRC emacs-lisp
(use-package git-gutter
  :ensure t
  :config (progn
            (add-hook 'git-gutter:update-hooks 'magit-after-revert-hook)
            (add-hook 'git-gutter:update-hooks 'magit-not-reverted-hook)
            (global-git-gutter-mode +1)
            (setq git-gutter:modified-sign "~")
            (setq git-gutter:added-sign "+")
            (setq git-gutter:deleted-sign "-")
            (setq git-gutter:window-width 3)
            (set-face-foreground 'git-gutter:modified "#b58900")
            (set-face-foreground 'git-gutter:added "#859900")
            (set-face-foreground 'git-gutter:deleted "#dc322f")
            (global-set-key (kbd "M-g s") 'git-gutter:stage-hunk)
            (global-set-key (kbd "M-g r") 'git-gutter:revert-hunk)
            (global-set-key (kbd "M-g m") #'git-gutter:mark-hunk)
            (global-set-key (kbd "M-g n") 'git-gutter:next-hunk)
            (global-set-key (kbd "M-g p") 'git-gutter:previous-hunk)))
#+END_SRC
** Git Time Machine
[[https://github.com/pidu/git-timemachine][git-timemachine]] lets me browse through previous commits in given file. It's not used often, but reverting files can be touchy operation and this package presents it in obvious way.

#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine :ensure t)
#+END_SRC
** Ediff
I like ~ediff~ more than ~smerge~, but that's probably just a personal preference. Give it a try.

#+BEGIN_SRC emacs-lisp
(use-package ediff
  :config (setq ediff-split-window-function 'split-window-horizontally))
#+END_SRC
* Programming
** General settings
*** Line numbers
Show line numbers in any programming mode.

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'linum-mode)
#+END_SRC

*** Indentation
Autoindent code (specifics are usually delegated to mode).
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'auto-indent-mode)
#+END_SRC

*** Camel Case
Treat CamelCase as separate words while editing.

#+BEGIN_SRC emacs-lisp
(subword-mode 1)
#+END_SRC
** Ruby
Use yard and robe modes with ~ruby-mode~.

#+BEGIN_SRC emacs-lisp
(add-hook 'ruby-mode-hook 'yard-mode)
(add-hook 'ruby-mode-hook 'robe-mode)
#+END_SRC
*** RSpec
When rake is available use it.

#+BEGIN_SRC emacs-lisp
(setq rspec-use-rake-when-possible nil)
#+END_SRC

Make RSpec get into editing mode on pry.

#+BEGIN_SRC emacs-lisp
(add-hook 'compilation-filter-hook 'inf-ruby-auto-enter)
#+END_SRC

Scroll to the first test failure

#+BEGIN_SRC emacs-lisp
(setq compilation-scroll-output 'first-error)
#+END_SRC

Don't ask for confirmation of save when compiling
#+BEGIN_SRC emacs-lisp
(setq compilation-ask-about-save nil)
#+END_SRC
*** Rubocop
[[https://github.com/bbatsov/rubocop][rubocop]] is a static code analyzer, made to enforce good practices in coding. When you install rubocop gem (~gem install rubocop~), you can add [[https://github.com/bbatsov/rubocop-emacs][rubocop-emacs]] to integrate it with Emacs.
#+BEGIN_SRC emacs-lisp
(use-package rubocop
  :ensure t
  :init (require 'ruby-mode)
  :config (add-hook 'ruby-mode-hook #'rubocop-mode))
#+END_SRC
** Lisp
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :config
  (setq sp-show-pair-from-inside nil)
  (require 'smartparens-config)
  :diminish smartparens-mode)
#+END_SRC
* Small side packages
** Touch typing
Spare minutes are best spent on practicing some touch typing and I added some packages that can be helpful.

*** speed-type
[[https://github.com/hagleitn/speed-type][speed-type]] takes practicing examples on random which sometimes can be demanding with exotic examples that it puts in front of you.

#+BEGIN_SRC emacs-lisp
(use-package speed-type :ensure t)
#+END_SRC
*** typit
[[https://github.com/mrkkrp/typit][typit]] is convenient for building speed on common words.

#+BEGIN_SRC emacs-lisp
(use-package typit :ensure t)
#+END_SRC



